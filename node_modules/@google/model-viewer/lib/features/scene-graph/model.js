/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a, _b, _c, _d;
import { Mesh } from 'three';
import { Material } from './material.js';
import { $children, Node, PrimitiveNode } from './nodes/primitive-node.js';
export const $materials = Symbol('materials');
const $hierarchy = Symbol('hierarchy');
const $roots = Symbol('roots');
export const $primitives = Symbol('primitives');
export const $loadVariant = Symbol('loadVariant');
export const $correlatedSceneGraph = Symbol('correlatedSceneGraph');
export const $prepareVariantsForExport = Symbol('prepareVariantsForExport');
export const $switchVariant = Symbol('switchVariant');
export const $threeScene = Symbol('threeScene');
export const $materialsFromPoint = Symbol('materialsFromPoint');
export const $materialFromPoint = Symbol('materialFromPoint');
// Holds onto temporary scene context information needed to perform lazy loading
// of a resource.
export class LazyLoader {
    constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {
        this.gltf = gltf;
        this.gltfElementMap = gltfElementMap;
        this.mapKey = mapKey;
        this.doLazyLoad = doLazyLoad;
    }
}
/**
 * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.
 * Currently, the model only bothers itself with the materials in the Three.js
 * scene graph.
 */
export class Model {
    constructor(correlatedSceneGraph, onUpdate = () => { }) {
        this[_a] = new Array();
        this[_b] = new Array();
        this[_c] = new Array();
        this[_d] = new Array();
        const { gltf, threeGLTF, gltfElementMap } = correlatedSceneGraph;
        this[$threeScene] = threeGLTF.scene;
        for (const [i, material] of gltf.materials.entries()) {
            const correlatedMaterial = gltfElementMap.get(material);
            if (correlatedMaterial != null) {
                this[$materials].push(new Material(onUpdate, gltf, material, correlatedMaterial));
            }
            else {
                const elementArray = gltf['materials'] || [];
                const gltfMaterialDef = elementArray[i];
                // Loads the three.js material.
                const capturedMatIndex = i;
                const materialLoadCallback = async () => {
                    const threeMaterial = await threeGLTF.parser.getDependency('material', capturedMatIndex);
                    // Adds correlation, maps the variant gltf-def to the
                    // three material set containing the variant material.
                    const threeMaterialSet = new Set();
                    gltfElementMap.set(gltfMaterialDef, threeMaterialSet);
                    threeMaterialSet.add(threeMaterial);
                    return { set: threeMaterialSet, material: threeMaterial };
                };
                // Configures the material for lazy loading.
                this[$materials].push(new Material(onUpdate, gltf, gltfMaterialDef, correlatedMaterial, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));
            }
        }
        // Creates a hierarchy of Nodes. Allows not just for switching which
        // material is applied to a mesh but also exposes a way to provide API
        // for switching materials and general assignment/modification.
        // Prepares for scene iteration.
        const parentMap = new Map();
        const nodeStack = new Array();
        for (const object of threeGLTF.scene.children) {
            nodeStack.push(object);
        }
        // Walks the hierarchy and creates a node tree.
        while (nodeStack.length > 0) {
            const object = nodeStack.pop();
            let node = null;
            if (object instanceof Mesh) {
                node = new PrimitiveNode(object, this.materials, correlatedSceneGraph);
                this[$primitives].push(node);
            }
            else {
                node = new Node(object.name);
            }
            const parent = parentMap.get(object);
            if (parent != null) {
                parent[$children].push(node);
            }
            else {
                this[$roots].push(node);
            }
            this[$hierarchy].push(node);
            for (const child of object.children) {
                nodeStack.push(child);
                parentMap.set(object, node);
            }
        }
    }
    /**
     * Materials are listed in the order of the GLTF materials array, plus a
     * default material at the end if one is used.
     *
     * TODO(#1003): How do we handle non-active scenes?
     */
    get materials() {
        return this[$materials];
    }
    getMaterialByName(name) {
        const matches = this[$materials].filter(material => {
            return material.name === name;
        });
        if (matches.length > 0) {
            return matches[0];
        }
        return null;
    }
    /**
     * Intersects a ray with the Model and returns a list of materials whose
     * objects were intersected.
     */
    [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitives, $materialsFromPoint)](raycaster) {
        const hits = raycaster.intersectObject(this[$threeScene], true);
        // Map the object hits to primitives and then to the active material of
        // the primitive.
        return hits.map((hit) => {
            const found = this[$hierarchy].find((node) => {
                if (node instanceof PrimitiveNode) {
                    const primitive = node;
                    if (primitive.mesh === hit.object) {
                        return true;
                    }
                }
                return false;
            });
            if (found != null) {
                return found.getActiveMaterial();
            }
            return null;
        });
    }
    /**
     * Intersects a ray with the Model and returns the first material whose
     * object was intersected.
     */
    [$materialFromPoint](raycaster) {
        const materials = this[$materialsFromPoint](raycaster);
        if (materials.length > 0) {
            return materials[0];
        }
        return null;
    }
    /**
     * Switches model variant to the variant name provided, or switches to
     * default/initial materials if 'null' is provided.
     */
    async [$switchVariant](variantName) {
        const promises = new Array();
        for (const primitive of this[$primitives]) {
            promises.push(primitive.enableVariant(variantName));
        }
        await Promise.all(promises);
    }
    async [$prepareVariantsForExport]() {
        const promises = new Array();
        for (const primitive of this[$primitives]) {
            promises.push(primitive.instantiateVariants());
        }
        await Promise.all(promises);
    }
}
//# sourceMappingURL=model.js.map